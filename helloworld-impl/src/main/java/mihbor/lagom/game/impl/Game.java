package mihbor.lagom.game.impl;

import java.util.Optional;
import java.util.Arrays;

import com.google.gdata.util.common.base.Preconditions;
import com.lightbend.lagom.javadsl.persistence.PersistentEntity;

import mihbor.lagom.game.impl.GameEvent.*;

public class Game extends PersistentEntity<GameCommand, GameEvent, GameState> {

	@Override
	public PersistentEntity<GameCommand, GameEvent, GameState>.Behavior initialBehavior(Optional<GameState> snapshot) {
		
		BehaviorBuilder b = newBehaviorBuilder(snapshot.orElse(GameState.EMPTY));
		
		proposeGameBehavior(b);
		joinGameBehavior(b);
		startGameBehavior(b);
		endTurnBehavior(b);
		commonEventHandlers(b);
		
		return b.build();
	}

	private void proposeGameBehavior(PersistentEntity<GameCommand, GameEvent, GameState>.BehaviorBuilder b) {

		b.setCommandHandler(
			ProposeGameImpl.class, 
			(cmd, ctx) -> {
				GameProposed gameProposed = GameProposedImpl.builder()
					.gameId(cmd.getGameId())
					.build();
				if(state() == GameState.EMPTY) {
					return ctx.thenPersist(gameProposed, evt -> ctx.reply(evt));
				} else { // already proposed, we're idempotent, so reply GameProposed
					assert state().gameId == cmd.getGameId(); // this must hold as this is the identifier for this entity!
					ctx.reply(gameProposed);
					return ctx.done();
				}
			}
		);
		
		b.setEventHandler(GameProposedImpl.class, evt -> state().gameProposed(evt.getGameId()));
	}

	private void joinGameBehavior(PersistentEntity<GameCommand, GameEvent, GameState>.BehaviorBuilder b) {
		
		b.setCommandHandler(
			JoinGameImpl.class, 
			(cmd, ctx) -> {
				PlayerJoinedGame playerJoined = PlayerJoinedGameImpl.builder()
					.gameId(state().gameId)
					.playerId(cmd.getPlayerId())
					.build();
				// idempotency again
				if(!state().hasPlayer(cmd.getPlayerId())) {
					return ctx.thenPersist(playerJoined, evt -> ctx.reply(evt));
				} else {
					ctx.reply(playerJoined);
					return ctx.done();
				}
			}
		);
		
		b.setEventHandler(PlayerJoinedGameImpl.class, evt -> state().playerJoinedGame(evt.getPlayerId()));
	}
	
	private void startGameBehavior(PersistentEntity<GameCommand, GameEvent, GameState>.BehaviorBuilder b) {
		
		b.setCommandHandler(
			StartGameImpl.class, 
			(cmd, ctx) -> {
				Preconditions.checkState(state().getPlayerCount() > 0, "can't start game without at least one player");
				GameStarted gameStarted = GameStartedImpl.builder()
					.gameId(state().gameId)
					.build();
				if(!state().isStarted) {
					PlayersTurnBegun playersTurnBegun = PlayersTurnBegunImpl.builder()
						.gameId(state().gameId)
						.playerId(state().getNextTurnsPlayersId())
						.turn(0)
						.build();
					return ctx.thenPersistAll(
						Arrays.asList(gameStarted, playersTurnBegun),
						() -> ctx.reply(gameStarted)
					);
				} else {
					ctx.reply(gameStarted);
					return ctx.done();
				}
			}
		);
		
		b.setEventHandler(GameStartedImpl.class, evt -> state().gameStarted());
	}

	private void endTurnBehavior(PersistentEntity<GameCommand, GameEvent, GameState>.BehaviorBuilder b) {
		
		b.setCommandHandler(
			EndTurnImpl.class,
			(cmd, ctx) -> {
				if(cmd.getTurn() == state().turn && cmd.getPlayerId().equals(state().getCurrentTurnsPlayersId())) {
					PlayersTurnEnded playersTurnEnded = PlayersTurnEndedImpl.builder()
						.gameId(state().gameId) 
						.playerId(cmd.getPlayerId()) 
						.turn(state().turn)
						.build();
					PlayersTurnBegun playersTurnBegun = PlayersTurnBegunImpl.builder()
						.gameId(state().gameId)
						.playerId(state().getNextTurnsPlayersId())
						.turn(state().turn+1)
						.build();
					return ctx.thenPersistAll(
						Arrays.asList(playersTurnEnded, playersTurnBegun), 
						() -> ctx.reply(playersTurnEnded)
					);
				} else if(cmd.getTurn() == state().turn-1 && cmd.getPlayerId().equals(state().getPreviousTurnsPlayerId())) { //idempotency
					ctx.reply(PlayersTurnEndedImpl.builder()
						.gameId(state().gameId)
						.playerId(cmd.getPlayerId())
						.turn(cmd.getTurn())
						.build());
					return ctx.done();
				} else {
					ctx.invalidCommand("not your turn to end");
					return ctx.done();
				}
			}
		);
		
		b.setEventHandler(PlayersTurnEndedImpl.class, evt -> state().playersTurnEnded(evt.getPlayerId()));
	}

	private void commonEventHandlers(PersistentEntity<GameCommand, GameEvent, GameState>.BehaviorBuilder b) {
		
		// this event is generated by both StartGame and EndTurn commands:
		b.setEventHandler(PlayersTurnBegunImpl.class, evt -> state().playersTurnBegun(evt.getPlayerId(), evt.getTurn()));
	}
}
